.data
    contador:   .word 0
    a:          .word 0
    verify_a:   .word 0
    mul_m:      .word 0
    mul_i:      .word 0
    zero:       .word 0
    mul_one:    .word 1
    mul_a:      .word 0
    uno:        .word 1
    dos:        .word 2
    tres:       .word 3
    div_a:      .word 0
    div_q:      .word 0
    div_r:      .word 0
    div_one:    .word 1
    max_val:    .word 0
    
    input_msg:  .asciz "Ingrese numero: "
    output_msg: .asciz "Maximo: %d\n"
    input_fmt:  .asciz "%d"
    
.text
.global main
.extern printf
.extern scanf

main:
    push {lr}
    
    // INPUT - leer contador
    ldr r0, =input_msg
    bl printf
    
    ldr r0, =input_fmt
    ldr r1, =contador
    bl scanf
    
loop:
    // LOAD CONTADOR
    ldr r1, =contador
    ldr r0, [r1]
    
    // SkipCond 800 (si contador == 0, saltar a fin)
    cmp r0, #0
    beq fin
    
    // Llamar a INICIO
    bl inicio
    
    // Después de procesar un número, mostrar el máximo
    ldr r0, =output_msg
    ldr r1, =max_val
    ldr r1, [r1]
    bl printf
    
    // LOAD CONTADOR, SUBT uno, STORE CONTADOR
    ldr r1, =contador
    ldr r0, [r1]
    sub r0, r0, #1
    str r0, [r1]
    
    b loop

inicio:
    push {lr}
    
    // INPUT
    ldr r0, =input_msg
    bl printf
    
    ldr r0, =input_fmt
    ldr r1, =a
    bl scanf
    
    // Actualizar MAX inicial
    bl actualizar_max
    
    // Procesar secuencia de Collatz
    bl procesar_collatz
    
    pop {lr}
    bx lr

procesar_collatz:
    push {lr}
    
collatz_loop:
    // Verificar si a == 1 (condición de parada)
    ldr r1, =a
    ldr r0, [r1]
    cmp r0, #1
    beq collatz_end
    
    // Determinar si es par o impar
    and r2, r0, #1      // r2 = a & 1 (bit menos significativo)
    cmp r2, #0
    beq es_par_collatz  // Si bit es 0, es par
    b es_impar_collatz  // Si bit es 1, es impar

es_par_collatz:
    // Dividir a por 2
    ldr r1, =a
    ldr r0, [r1]
    lsr r0, r0, #1      // División por 2 usando shift right
    str r0, [r1]
    
    // Actualizar MAX
    bl actualizar_max
    
    b collatz_loop

es_impar_collatz:
    // Multiplicar por 3 y sumar 1: a = 3*a + 1
    ldr r1, =a
    ldr r0, [r1]
    
    // Multiplicar por 3: a = a + 2*a
    add r0, r0, r0, lsl #1  // r0 = r0 + (r0 << 1) = r0 + 2*r0 = 3*r0
    add r0, r0, #1          // r0 = 3*r0 + 1
    
    str r0, [r1]
    
    // Actualizar MAX
    bl actualizar_max
    
    b collatz_loop

collatz_end:
    pop {lr}
    bx lr

actualizar_max:
    push {lr}
    
    // LOAD a, comparar con MAX
    ldr r1, =a
    ldr r0, [r1]
    ldr r1, =max_val
    ldr r2, [r1]
    
    cmp r0, r2
    ble no_update   // Si a <= MAX, no actualizar
    
    // a > MAX, actualizar
    str r0, [r1]
    
no_update:
    pop {lr}
    bx lr

fin:
    // Terminar programa
    mov r0, #0      // return 0
    pop {lr}
    bx lr