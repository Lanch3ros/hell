ORG 100
    INPUT
    STORE CONTADOR

LOOP, LOAD CONTADOR
    SkipCond 800
	JUMP FIN
	
    JnS INICIO

DISCOUNTLOOP, LOAD MAX
	OUTPUT
	LOAD CONTADOR
    SUBT uno
    STORE CONTADOR
    JUMP LOOP

INICIO, DEC 0
	Input
    Store a	
	Jns ACTUALIZAR_MAX
    JnS finCollatz
    JnS cicloCollatz
 
cicloCollatz, Load a
Load a
Store verify_a    
JnS verify
 
 
/par o impar?
verify, DEC 0
ciclo, Load verify_a 
Skipcond 400  / Si R == 0, es par
Jump cicloRes/no
Jump es_par /yes
cicloRes, Load verify_a
Subt dos  
Skipcond 000  / Si resultado < 0, es impar (R == 1)
Jump no_action/no
Jump es_impar  /yes
no_action, Store verify_a  
Jump ciclo
 
es_impar, Load uno
JnS ESIMPAR
JnS finCollatz
JnS cicloCollatz
JumpI verify
 
es_par, Load zero
JnS ESPAR
JnS finCollatz
JnS cicloCollatz
JumpI verify
 
finCollatz, DEC 0
Load a
Subt uno
SkipCond 400
JumpI finCollatz/no
JUMP DISCOUNTLOOP
 
 
/si es par  se divide entre 2

ESPAR, DEC 0
    LOAD a
    STORE div_a
    JnS div
    STORE a
    JnS ACTUALIZAR_MAX
    JumpI ESPAR

 
/si es impar se triplica y se suma 1
ESIMPAR, DEC 0
    LOAD a
    STORE mul_a
    JnS mul
    STORE a
    JnS ACTUALIZAR_MAX   / ? después de multiplicar por 3
    LOAD a
    ADD uno
    STORE a
    JnS ACTUALIZAR_MAX   / ? después de sumar 1
    JumpI ESIMPAR

 
ACTUALIZAR_MAX, DEC 0
    LOAD a
    SUBT MAX
    SKIPCOND 000     / Si a == MAX ? no actualizar
    SKIPCOND 800     / Si a > MAX ? actualizar
    JUMP NO_UPDATE
    LOAD a
    STORE MAX
NO_UPDATE, JUMPI ACTUALIZAR_MAX

/------------------------------------------------
/divide entre 2
div, dec 0
clear 
Store div_q / m=0
Load div_a
Store div_r /r=a
 
div_while, Load div_r
Subt dos
Store div_r
Skipcond 400 
Jump positiv /no
Jump next /yes
 
positiv, skipcond 800
Jump div_endw  /no
Jump next /yes
 
next, Store div_r
load div_q   
ADD div_one
store div_q  / q=q+1
jump div_while
 
div_endw, Load div_q
JumpI div
 
/multiplica por 3
mul, DEC 0
 
Load zero
store mul_m / m=0
store mul_i /i=0
 
mul_while, Load mul_i
subt mul_a
skipcond 000 /i<a?
Jump mul_endw /no
load mul_m /yes
add tres
store mul_m / m= m+b
 
load mul_i
add mul_one
store mul_i / i=i+1
 
Jump mul_while
 
mul_endw, load mul_m
JumpI mul


FIN, HALT


a, DEC 0
verify_a, DEC 0
mul_m, DEC 0
mul_i, DEC 0
zero, DEC 0
mul_one, DEC 1
mul_a, DEC 0
uno, DEC 1
dos, DEC 2
tres, DEC 3
div_a, DEC 0   
div_q, DEC 0  
div_r, DEC 0   
div_one, DEC 1
CONTADOR, DEC 0
MAX, DEC 0